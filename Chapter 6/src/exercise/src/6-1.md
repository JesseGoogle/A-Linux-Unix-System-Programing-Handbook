# 全局变量与可执行文件大小的关系

当你在程序中声明一个全局未初始化的数组时，比如一个 `int` 类型的数组 `int array[1024 * 1024 * 45];`，但是，编译后的可执行文件大小通常并不会直接反映出这个数组的实际占用空间，原因有以下几点：

1. **静态存储与动态分配**：编译器并不一定会将这么大一块未初始化的静态数据实际包含在可执行文件中。对于未初始化的全局变量，编译器可能只会为其预留必要的元数据（如地址和大小信息），而不会分配实际的内存空间到可执行文件中。真正的内存分配会在程序运行时由操作系统完成，当程序加载到内存中时才会占用相应的空间。

2. **链接时优化**：现代链接器在链接阶段会对程序进行各种优化，包括去除未使用的符号、折叠重复的数据等。如果这个大数组没有在程序中被显式引用，编译器和链接器有可能会将其视为未使用并从最终的可执行文件中移除。

3. **编译器优化**：编译器可能会对程序进行各种分析，如果确定某个大型数据结构实际上不需要在程序启动时就占据内存（特别是未初始化的），它可能会采取一些策略减少其对可执行文件大小的影响。

4. **内存映射文件**：在程序运行时，操作系统可以使用内存映射文件的技术来处理大块的未初始化数据。这意味着虽然逻辑上分配了空间，但并不立即消耗物理内存或磁盘上的可执行文件空间，而是在数据真正被访问时才分配或从磁盘上的交换空间读取。

综上所述，尽管你在源代码中声明了一个大数组，但编译器和操作系统的一系列机制使得可执行文件的实际大小并不直接反映这一数组的内存需求。在程序运行时，该数组会占用相应的内存空间，但这部分空间并不计入可执行文件本身的大小。
